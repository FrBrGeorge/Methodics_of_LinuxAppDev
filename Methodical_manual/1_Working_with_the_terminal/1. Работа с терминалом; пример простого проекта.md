Сегодня будет заниматься по большому счёту программированием. Посмотрим, как в этой идеологии вообще проходит процесс разработки, глубоко в отдельые утилиты не влезая

---
Немного поговорим про терминал
---
Терминал - это устройство, которое обеспечивает ввод-вывод байтов на компьютер.
Немного истории: терминал представлял из себя машинку, которая печатает на бумажку текст, после чего можно загнать это в компьютер, и он на бумажку после выводит ответ
(Добавить фотку)

---
Поскольку клавиатура с принтером/ЭЛТ стали местом управления компьютером, появилась мысль, а как собственно управлять?
Некоторые байты от этого стали управляющими. Система воспринимает их отдельно от текста и выполняет заданные алгоритмы

`stephen@localhost:~> stty -a`
`speed 38400 baud; rows 24; columns 80; line = 0;`
`intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;`
`eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;`
`werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;`
`-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts`
`-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff`
`-iuclc -ixany -imaxbel iutf8`
`opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0`
`isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt`
`echoctl echoke -flusho -extproc`
`stephen@localhost:~>` 

stty описывает нам как бы наш ком-порт со всеми этими спецсигналами

---
Следующее преобразование, с которым работает терминал - следствие той самой печатной машинки - свои собственные символы конца строки (разные в разных ОС) и "возврата каретки"

А также примитивное редактирование ввода-вывода. В наших терминалах для выделения текста (подчёркивание и жирный шрифт) используются как бы старые идеи - сдвиг каретки и подчёркивание или двойная печать

---
---
Новые преимущества современных терминалов
В наших терминалах встречаются символы, которые обеспечивают нам работу с адаптированным интерфейсом
(esc-последовательности - управляющие)

У большинства терминалов поддержка всех этих символов есть

---
---

```
stephen@localhost:~> infocmp vt52
#	Reconstructed via infocmp from file: /usr/share/terminfo/v/vt52
vt52|DEC VT52,
	cols#80, it#8, lines#24,
	acsc=+h.k0affggolpnqprrss, bel=^G, clear=\EH\EJ, cr=\r,
	cub1=\ED, cud1=\EB, cuf1=\EC,
	cup=\EY%p1%' '%+%c%p2%' '%+%c, cuu1=\EA, ed=\EJ, el=\EK,
	home=\EH, ht=^I, ind=\n, ka1=\E?q, ka3=\E?s, kb2=\E?r, kbs=^H,
	kc1=\E?p, kc3=\E?n, kcub1=\ED, kcud1=\EB, kcuf1=\EC,
	kcuu1=\EA, kf0=\E?y, kf1=\EP, kf2=\EQ, kf3=\ER, kf5=\E?t,
	kf6=\E?u, kf7=\E?v, kf8=\E?w, kf9=\E?x, nel=\r\n, ri=\EI,
	rmacs=\EG, rmkx=\E>, smacs=\EF, smkx=\E=, u8=\E/[KL], u9=\EZ,
stephen@localhost:~> 

```

Достоинство всего legacy - нет ничего непонятного: ВСЁ, что мы нажимаем, воспринимается, как esc-последовательность. Всё везде унифицировано

Информацию про все тонкости нашего терминаламожно посмотреть в infocmp (tput)

(Упоминание построчного редактора `ed`)

(Прикол с графикой в терминале, написанной на esc-последовательностях)

---
---
---

Разбираться с тем, как самим применять esc-последовательности в работе, будем на Си. Можно фигачить и через Shell с помощью утилиты dialog (примерчик протыкать)

Для того, чтобы воспользоваться всем этим багадом терминала на Си без безумных обращений к захардаченым последовательностям, будем использовать библиотеку ***NCurses***

Идея такая: считаем, что у нас есть экран - прямоугольник. Мы его как-то заполняем, обновляем, и у нас показывается наша прога

Экран надо инициализировать. Для начала надо включить *raw mode* вместо *cooked mode*, чтобы любой символ сразу обрабатывался, а не ожидал ввода.

Пример:
```
#include <curses.h>
main ()
{
        initscr ();
        move (LINES/2 - 1, COLS/2 - 4);
        addstr ("Hello, World!");
        getch ();
        endwin ();
}
```


```
#include <curses.h>
// #include <locale.h>

int main(void) {
	WINDOW* win;
	char c = 0;

	// setlocale(LC_ALL, "");

	initscr();
	noecho();
	cbreak();

	printw("window:"); // TODO: переделать пример - мы рисуем бокс внутри окна и перекрывает первую строку
	refresh();

	win = newwin(LINES - 5, COLS - 5, 3, 6);
	keypad(win, TRUE);
	scrollok(win, TRUE);

	box(win, 0, 0); // TODO: Переделать пример: у нас скроллится box
	wmove(win, 0, 1);

	while((c = wgetch(win)) != 27) {
		wprintw(win, "  %d: %s\n", c, keyname(c));
		box(win, 0, 0);
		wrefresh(win);
	}

	endwin();
	return 0;
}


```

---
---
---
Для того, чтобы не делать всю машинерию руками, для автоматической сборки можно сделать ***makefile***

Мейк-файл - это сборник рецептов по тому, как собирать из одних исходников другие, из других - третьи итд
```
SRC=curses.c
EXE=curses
CC=cc
LIBS=-lcurses
CFLAGS=-Wall

%:	%.c
	$(CC) $(CFLAGS) $< $(LIBS) -o $@
# Обязательна ТАБУЛЯЦИЯ
# Cначала файл, потом библиотеки, порядок важен

```

 У мейка есть взможность вызова целей не только связаных внешними объектами, но и просто с командами

При работе по умолчанию ищется первая непараметризованная цель ИЛИ цель по умолчанию `all`

```
TODO: версия с clean и all
```