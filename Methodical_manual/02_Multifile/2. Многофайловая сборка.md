Данный раздел продолжает повествование о работе с утилитой make при автосборке для многофайловых проектов. 

Вообще, многофайловость проектов  - это достаточно популярная парадигма языков программирования. Она упрощает ориентирование в программе, разделяет информационные блоки кода, и при изменении какого-то из файлов перекомпилировать нужно будет только его и зависящие от него, а не всю программу.
В случае Си многофайловость играет ещё одну важную роль: это единственный способ разделить глобальные пространства имён и в каждом модуле использовать свои глобальные переменные.

Первая многомодульная сборка
---
Рассмотрим простую многомодульную программу и будем постепенно усложнять `Makefile` для компиляции проекта

`prog.c` - Основная программа
```c
#include "outlib.h"
int main(int argc, char *argv[]) {
    Count = argc;
    output("<INIT>");
    output(argc>1 ? argv[1] : "<NOPE>");
    output("<DONE>");
    return 0;
}
```

`fun.c` - Описание выводящей функции
```c
#include <stdio.h>
#include "outlib.h"
void output(char *str) {
        printf("%d: %s\012", Count++, str);
}
```

`const.c` - Глобальные переменные, видные всему проекту
```c
int Count=0;
```

`outlib.h` - Header-файл
```c
void output(char *);
extern int Count;
```


Сначала самыйпримитивный вариант: просто всё скомпилировать командой 
`cc *.c -o prog`

Однако, в будущем мы так поступать не хотим, тк здесь ведётся трансляция всех файлов сразу. Если бы их было сильно дольше, мы бы, как минимум, проигрывали в скорости компиляции.


Напишем `Makefile` для проекта
```make
prog:   const.c fun.c prog.c
    cc const.c fun.c prog.c -o prog
clean:
	rm -f prog
```

`Makefile` состоит из множества описаных рецептов с указанными целями, для каждого из них опционально присутствуют исходники.

Ещё раз проговорим особенности и задачи `make`:
 + _Построение графа зависимостей._ На его основе утилита делает пересборку только по тем рецептам, у которых были произведены изменения (и у зависимых от них). При этом можно запустить компиляции сразу нескольких ветвей компиляции одновременно, если они независимы
 + _Удаление мусора и промежуточных генератов._ В том числе, удаляться могут те файлы, которые мы, как разработчики, считаем генератом (то, что нужно было один раз для компиляции чего-то). Генератами считаются бинарные файлы, библиотеки и объектные файлы. Однако, бинарники и библиотеки мы выделим в особый класс генеративных файлов, которые далеко не всегда являются промежуточными и должны быть сохранены.

Улучшение Makefile
---

Преобразим `Makefile` из нашего примера: в предыдущем случае  проводилась перекомпиляция всего проекта даже при изменении лишь одного из файлов. 
Для разделения блоков опишем вызов компилятора для каждого файла отдельно, после чего будем производить компоновку готовых объектных файлов. А для удаления тех самых объектников добавим в рецепт цели `clean` дополнительные параметры.

```make
prog:   const.o fun.o prog.o
	cc const.o fun.o prog.o -o prog

fun.o:  fun.c 
	cc fun.c -c -o fun.o

prog.o: prog.c 
	cc prog.c -c -o prog.o

const.o:        const.c 
	cc const.c -c -o const.o

clean:
	rm -f prog *.o
```

Следующий этап улучшения автосборки - написание рецептов через шорт-каты: Цели `$@` и Исходников `$^`(первый исходник имеет свой особый шорт-кат `$<`)

```make
prog:   const.o fun.o prog.o
	cc const.o fun.o prog.o -o prog

fun.o:  fun.c 
	cc $< -c -o $@

prog.o: prog.c 
	cc $< -c -o $@

const.o:        const.c 
	cc $< -c -o $@

clean:
	rm -f prog *.o
```

В нашем мейк-файле получились три одинаковых рецепта. Их можно объединить с помощью параметризируемых параметров:

```make
all:    prog

%.o:  %.c 
	cc $< -c -o $@

prog:   const.o fun.o prog.o
	cc $^ -o $@

clean:
	rm -f prog *.o
```

Увидим, что перекомпиляция теперь работает независимо по файлам:

```console
admin@localhost: make clean
rm -f prog *.o

admin@localhost: make prog
cc const.c -c -o const.o
cc fun.c -c -o fun.o
cc prog.c -c -o prog.o
cc const.o fun.o prog.o -o prog

admin@localhost: touch fun.c 
admin@localhost: make prog  
cc fun.c -c -o fun.o
cc const.o fun.o prog.o -o prog

admin@localhost: touch fun.o
admin@localhost: make prog  
cc const.o fun.o prog.o -o prog
```

При этом видим, что программа корректно работает после сборки:
```console
admin@localhost:~/LinuxAppDev/02_Multifile> ./prog
1: <INIT>
2: <NOPE>
3: <DONE>
admin@localhost:~/LinuxAppDev/02_Multifile> ./prog Hahaha
2: <INIT>
3: Hahaha
4: <DONE>
admin@localhost:~/LinuxAppDev/02_Multifile> 
```

Вторая многомодульная сборка
---
Изменим нашу программу под работу со множеством аргументов:
  
`prog.c` - Основная программа
```c
#include <stdio.h>
#include "outlib.h"

int main(int argc, char *argv[]) {
  int i;
    if((Count = argc)>1) {
      output("<INIT>");
      for(i=1; i<argc; i++)
        output(argv[i]);
      output("<DONE>");
    }
    else
      usage(argv[0]);
 return 0;
}
```

`fun.c` - Описание выводящей функции
```c
#include <stdio.h>
#include "outlib.h"
void output(char *str) {
        printf("%d: %s\012", Count++, str);
}

void usage(char *prog) {
    fprintf(stderr, "%s v%.2f: Print all arguments\012\t"\
                "Usage: %s arg1 [arg2 […]]\012", prog, VERSION, prog);
}
```

`const.c` - Глобальные переменные, видные всему проекту
```c
int Count=0;
```

`outlib.h` - Header-файл
```c
void output(char *);
void usage(char *);
extern int Count;
#define VERSION 0.0
```

 И также продолжим усложнять `Makefile`: разделим удаление генератов и объектных файлов; для описания этих файлов воспользуемся переменными окружения; добавим файл `README`, который будет генерироваться по нашему бинарнику:

```make
.PHONY: clean distclean
GENS = prog README
TRASH = *.o *~ o.*

%.o:    %.c
       cc $< -c -o $@

all:    prog README

prog:   const.o fun.o prog.o
 cc $^ -o $@

README: prog
   ./$< > $@ 2>&1

clean:
  rm -f $(TRASH)

distclean:      clean
       rm -rf $(GENS)
```

Цели `clean` и `distclean` мы помечаем специальной меткой `.PHONY`. Данная метка явно указывает, что эти цели не связаны с именами файлов, совпадающих с ними (на случай, если файлы с такими именами у нас будут), благодаря чему эти цели будут выполняться независимо от изменения этих файлов.
`make` ориентируется при выборе целей для исполнения на соответствие времени изменения исходных данных и самой цели. И в случае, если итоговый объект был сделан раньше последних изменений исходников, производится пересборка рецепта. `.PHONY`-цели помечаются утилитой как "только что изменённые" при каждом её вызове, благодаря чему исполняются постоянно. 

Вернёмся к `Makefile`
У нас в рецептах есть важная проблема: изменение `outlib.h` никак не влияет на пересборку. Мы можем беспрепятственно менять его без пересборки, чего быть, вообще говоря, не должно. 

```console
admin@localhost:~/LinuxAppDev/02_Multifile> make distclean
rm -f *.o *~ o.*
rm -rf prog README

admin@localhost:~/LinuxAppDev/02_Multifile> make
cc const.c -c -o const.o
cc fun.c -c -o fun.o
cc prog.c -c -o prog.o
cc const.o fun.o prog.o -o prog
./prog > README 2>&1

admin@localhost:~/LinuxAppDev/02_Multifile> make
make: Nothing to be done for 'all'.

admin@localhost:~/LinuxAppDev/02_Multifile> touch outlib.h 
admin@localhost:~/LinuxAppDev/02_Multifile> make
make: Nothing to be done for 'all'.
```

Для учитывания зависимости добавим отдельную цель для её описания. При этом заметим, что её рецепт будет пустым

```make
.PHONY: clean distclean
GENS = prog README
TRASH = *.o *~ o.*

%.o:	%.c
	cc $< -c -o $@

all:	prog README

fun.o prog.o:	outlib.h

prog:	const.o fun.o prog.o
	cc $^ -o $@

README:	prog
	./$< > $@ 2>&1

clean:
	rm -f $(TRASH)

distclean:	clean
	rm -rf $(GENS)
```

```console
admin@localhost:~/LinuxAppDev/02_Multifile> make distclean all
rm -f *.o *~ o.*
rm -rf prog README
cc const.c -c -o const.o
cc fun.c -c -o fun.o
cc prog.c -c -o prog.o
cc const.o fun.o prog.o -o prog
./prog > README 2>&1

admin@localhost:~/LinuxAppDev/02_Multifile> make
make: Nothing to be done for 'all'.

admin@localhost:~/LinuxAppDev/02_Multifile> touch outlib.h 
admin@localhost:~/LinuxAppDev/02_Multifile> make
cc fun.c -c -o fun.o
cc prog.c -c -o prog.o
cc const.o fun.o prog.o -o prog
./prog > README 2>&1
```

Ненароком мы показали ещё одну особенность при работе с утилитой: возможность последовательно вызывать сразу несколько целей при явном их указании

Следующее улучшение `Makefile` - использование встроенных шаблонов рецептов, работающих на переменных окружения.
Добавим переменные, описывающие флаги компиляции и компилятор

```make
.PHONY: clean distclean
GENS = prog README
TRASH = *.o *~ o.*
CFLAGS = -Wall
CC = cc

all:	prog README

fun.o prog.o:	outlib.h

prog:	const.o fun.o prog.o
	cc $^ -o $@

README:	prog
	./$< > $@ 2>&1

clean:
	rm -f $(TRASH)

distclean:	clean
	rm -rf $(GENS)

```

```console
admin@localhost:~/LinuxAppDev/02_Multifile> make distclean all
rm -f *.o *~ o.*
rm -rf prog README
cc -Wall   -c -o const.o const.c
cc -Wall   -c -o fun.o fun.c
cc -Wall   -c -o prog.o prog.c
cc const.o fun.o prog.o -o prog
./prog > README 2>&1
```

Сборочные библиотеки
---
Для сборки проектов с использованием стороннего функционала мы часто обращаемся к сборочным библиотекам. Различают два вида библиотек: **_статические_**, с которыми мы собираем проект на этапе компиляции, и **_динамические_**, которые подгружаются непосредственно в момент запуска исполняемого файла. Использование статических библиотек гарантирует нам работу исполняемого файла без внешней поддержки, а использование динамических - даёт меньший размер бинарника и более быстрый запуск.      

Поговорим про каждый вид отдельно и попробуем воспроизвести их в нашем проекте.
Начнём со статической библиотеки. По сути своей, она представляет собой объектные файлы, сложенные архиватором в единый объект. Так как исполняемым модулем проекта у нас является только prog.o,  другие два объектника выступают в роли библиотечных, объединим их в библиотеку и соберём проект с ней:

```console
admin@localhost:~/LinuxAppDev/02_Multifile/Lection> ar -rcs libout.a const.o fun.o
```

Имя статической библиотеки должно соответствовать формату **_lib<name_of_library>.a_**. При сборке проекта с библиотекой используется флаг **_-l<name_of_library>_**, а также флаг **_-L_**, указывающий путь до присоединяемой библиотеки

```console
admin@localhost:~/LinuxAppDev/02_Multifile/Lection> cc prog.o -L. -lout -o prog
```


Научимся собирать библиотеку в `Makefile`. Сборка библиотеки для нас это промежуточное действие, при этом создаваемый нами генерат не должен автоматически удаляться (у нас написаны ручные цели `clean`  и `distclean`, но если использовать встроенные рецепты, библиотека бы автоматически всё время удалялась), поэтому мы помечаем его меткой `.SECONDARY`. Синтаксис описания сборки библиотеки описан ниже

```make
.PHONY: clean distclean
GENS = prog README
TRASH = *.o *~ o.*
CFLAGS = -Wall
CC = cc

all:	prog README

fun.o prog.o:	outlib.h

.SECONDARY:	libout.a(fun.o const.o)

libout.a:	libout.a(fun.o const.o)

prog:	prog.o libout.a
	cc $^ -o $@

README:	prog
	./$< > $@ 2>&1

clean:
	rm -f $(TRASH)

distclean:	clean
	rm -rf $(GENS)
```

```console
admin@localhost:~/LinuxAppDev/02_Multifile> make distclean all
rm -f *.o *~ o.*
rm -rf prog README libout.a
cc -Wall   -c -o prog.o prog.c
cc -Wall   -c -o fun.o fun.c
ar -rv libout.a fun.o
ar: creating libout.a
a - fun.o
cc -Wall   -c -o const.o const.c
ar -rv libout.a const.o
a - const.o
cc prog.o libout.a -o prog
./prog > README 2>&1
rm const.o

admin@localhost:~/LinuxAppDev/02_Multifile> ./prog
./prog v0.00: Print all arguments
	Usage: ./prog arg1 [arg2 […]]

admin@localhost:~/LinuxAppDev/02_Multifile> ./prog qwerty
2: <INIT>
3: qwerty
4: <DONE>

admin@localhost:~/LinuxAppDev/02_Multifile> ./prog qwerty asdf
3: <INIT>
4: qwerty
5: asdf
6: <DONE>
```


Теперь попробуем сорганизовать динамическую библиотеку. Название библиотеки отличается расширением (`.so` вместо `.a`), для сборки библиотеки нужно использовать флаги **_-shared_** и **_-fPIC_**. 

При запуске собранного проекта надо указывать библиотеку. В случае с `make` мы указываем путь до библиотеки через переменную окружения `LD_LIBRARY_PATH`
```make
.PHONY: clean distclean
GENS = prog README libout.so
TRASH = *.o *~ o.*
CFLAGS = -Wall -fPIC
CC = cc

all:	prog README

fun.o prog.o:	outlib.h

libout.so:	fun.o const.o
	$(CC) $^ -o $@ -shared

prog:   prog.o libout.so

README:	prog
	LD_LIBRARY_PATH=`pwd` ./$< > $@ 2>&1

clean:
	rm -f $(TRASH)

distclean:	clean
	rm -rf $(GENS)
```

```console
admin@localhost:~/LinuxAppDev/02_Multifile> make distclean all
rm -f *.o *~ o.*
rm -rf prog README libout.so
cc -Wall -fPIC   -c -o prog.o prog.c
cc -Wall -fPIC   -c -o fun.o fun.c
cc -Wall -fPIC   -c -o const.o const.c
cc fun.o const.o -o libout.so -shared
cc   prog.o libout.so   -o prog
LD_LIBRARY_PATH=`pwd` ./prog > README 2>&1

admin@localhost:~/LinuxAppDev/02_Multifile> cat README 
./prog v0.00: Print all arguments
	Usage: ./prog arg1 [arg2 […]]

```

---
Документации по мейку очень много, главное, не пытаться прочесть всё

Аналогичных мейку много, главный "синоним" - Ninja. Но он специально разработан, чтобы на высокоуровневом языке сборки писать. 