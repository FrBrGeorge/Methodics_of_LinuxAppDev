Данный раздел посвящён обширному классу языков склейки и, в частности, языку `Unix Shell`, как основному универсальному языку сборки проектов

Подробная [лекция](https://uneex.org/LecturesCMC/LinuxApplicationDevelopment2020/12_ScriptingText) по данной теме(2020г.)
Универсальность сборки
---
Сборка  - один из основных этапов разработки программного продукта. У каждого языка есть набор библиотек, функций и методов, позволяющих самостоятельно осуществлять сборку проекта на этом языке. Так, например, в рамках курса ["Совместная разработка приложений на Python"](https://uneex.org/LecturesCMC/PythonDevelopment2024) слушатели изучат python- утилиту `doit` по автосборке проектов.
Однако если нам требуется универсальность работы с программами (как в рамках сборки проектов, так и для простого взаимодействияс утилитами), нам на помощь приходят языки склейки.


Почти всегда мы работаем с какой-то машиной, или фреймворком, или сетевой средой, заполненной командами и утилитами. Всё это окружение уже умеет решать наши задачи по обработке каких-то входных данных, преобразованию и передаче их. Но при разработке отдельных утилит разработчик далеко не всегда закладывает ориентир на работу со сторонними утилитами и, тем более, пользовательскими программами. Или взаимодействие со сторонним приложением может требовать довольно сложных синтаскических конструкций.
Языки склейки, применяющиеся в качестве языков работы основного интерфейса управления нашей системы (в нашем случае, это командная строка), отвечают трём основным требованиям нашей работы:
 - С их помощью мы можем использовать команды, встроенные в нашу систему;
 - Множество доступных нам команд алгоритмически полно;
 - С их помощью настроен удобный интерфейс объединения команд, их суперпозиция

Unix Shell
---
`Unix Shell` - это удобный интерпретатор командной строки, поддерживающий работу с переменными, условные операторы, циклы, а, главное, умеющий просто и быстро работать с установленными в систему программами, а также объединять их. `Shell` преимущественно работает с текстовыми данными, вследствие чего в системах, поддерживающий `Shell` ,  очень много утилит для работы с текстом

В нашем конспекте мы будем обращаться к классическому `Shell`-у, а также к интерпретатору `Z Shell`
#### Работа с переменными
Для ускорения работы интерпретатора в нём организован однопроходный синтаксический анализ скрипта, из-за чего для однозначного определения переменных среди текстового потока они выделяются спецсимволом `$`. При этом для задания переменных этого не нужно, определение произойдёт за счёт однозначной интерпретации операции присваивания

```console
stephen@localhost:~> zsh
localhost% a=2
localhost% echo a
a
localhost% echo $a
2

localhost% a=4
localhost% echo $a
4
localhost% 
```

#### Арифметика
Арифметика в `Shell` устроена через внутреннее  `$`-представление результата выражения иличерез встроенную утилиту `expr`
```console
localhost% A=2;B=3

localhost% echo $A
2
localhost% echo $B
3

localhost% echo $((A+B))
5
localhost% echo $((A+B-13))
-8

localhost% expr $A + $B
5
```

#### Пространства имён
Так как интерпретатор может взаимодействовать с программами и запускать их на исполнение, при этом сам являясь программой, для пользователей открывается возможность создания раздельных пространств имён, в которых мы можем обрабатывать Shell-скрипты. Для взаимодействия пространств имён мы можем экспортировать переменные из внешнего пространства во внутреннее (обратное невозможно)

```console
stephen@localhost:~> zsh

localhost% A=1
localhost% echo $A
1

localhost% zsh 
localhost% echo $A

localhost% ASD=123
localhost% echo $ASD
123

localhost% exit
localhost% echo $ASD

localhost% echo A   
A

localhost% export A
localhost% zsh
localhost% echo $A
1
localhost% exit
localhost% exit
stephen@localhost:~> 
```

#### Функции
`Shell` поддерживает связывание имён на целые скрипты.
```console
stephen@localhost:~> A() { echo qq; }
stephen@localhost:~> A
qq
stephen@localhost:~> 

```

Для использования переменных в коде мы пользуемся логикой передачи параметров во вложенное пространство из внешнего. Для этого внутри отдельных скриптов мы можем задавать локальные переменные при помощи ключевого слова `local`

```console
localhost% func1() { local var='func1 local'; func2}
localhost% func2() {echo "In func2, var = $var"}
localhost% var=global

localhost% echo $var
global

localhost% func2
In func2, var = global

localhost% func1
In func2, var = func1 local

localhost% echo $var
global
```

#### Текстовая обработка
При работе с данными `Shell` может перед непосредственным выводом проводить пост-обработку полученных результатов
```console
stephen@localhost:~> A=123.456.678
stephen@localhost:~> echo ${A}b # вывод форматированного текста
123.456.678b
stephen@localhost:~> echo $Ab

```

**ОШИБКА в примере на Uneex**
```console
localhost% A=123/456/789 
localhost% echo $A
123/456/789
localhost% echo ${A}
123/456/789

localhost% echo ${A%/*} # Отрезание хвоста данных (отрезает последнее совпадение шаблону /*)
123/456
localhost% echo ${A%%/*} # Жадное отрезание хвоста (по первому совпадению)
123
localhost% echo ${A#*/} # отрезание головы (по первому совпадению)
456/789
localhost% echo ${A##*/} # Жадное отрезание головы (по последнему)
789

localhost% A=123.426.678
localhost% echo ${A/2/E} # замена первого совпадения
1E3.426.678
localhost% echo ${A//2/E} # Замена всех совпадений
1E3.4E6.678
```

$$ **Подумать, в какой раздел это писать и писать ли**
Большая часть того, что мы делаем - это внешние программы. При этом есть и внутренние программы, которые умеют подменять окружение и редачить его. Бывают внешние, раелизованные под внутренние (echo -e)

Поэтому крректный вопрос не "Сколько команд в Системе?" (Сколько поставили, столько и будет), а "Сколько команд в стандарте POSIX"
$$

#### Запуск скриптов в командной строке
Мы можем запускать сразу последовательности команд Shell - _скрипты_. При этом нам доступна возможность запуска их в фоновом режиме для продолжения 
Команды можно запускать в фоне 
```console
localhost% A=Hello
localhost% echo $A                                            
Hello

localhost% {sleep 1; echo 1; sleep 1; echo 2; sleep 1; echo QQ}  # запуск скрипта в данном* процессе
1
2
QQ
localhost% {sleep 1; echo 1; sleep 1; echo 2; sleep 1; echo QQ} & # запуск скрипта фоновым процессом - можем продолжать работу
[1] 189666
localhost% echo $A # успеваем вызывать другие команды Shell
Hello
1
localhost% echo $A
Hello
2
localhost% echo $A
Hello
QQ

[1]  + 189666 done       { sleep 1; echo 1; sleep 1; echo 2; sleep 1; echo QQ; }
localhost% 

```
*Справедливости ради (вспоминаем ОСи) все вызовы программ отрабатывают не в заданном процессе. Для всех них срабатывает `fork-exec` механизм для создания родственного процесса и подмены его необходимой к исполнению командой, просто в первом случае основной процесс ждёт завершения сыновьего, а во втором случае продолжает работу в ожидании сигнала от сыновьего процесса и данных о завершении в связующем канале.

#### Перенаправление ввода-вывода
Для удобства передачи данных на входной и с выходного потоков программ в `Shell` существуют спецсимволы перенаправления: 
 + `<` - перенаправление ввода
 + `>` - перенаправление вывода с перезаписыванием итогового места
 + `>>` - перенаправление вывода с дозаписыванием итогового места
 + `2>` / `2>>` - перенаправление потока ошибок
```console
localhost% ls  
bin  Desktop	dwe			  Music  o3	   Py.py
d    Documents	file			  o	 oqwer	   pythonprac
d1   dotfiles	LinuxAppDev		  o1	 Pictures  Templates
d34  Downloads	Methodics_of_LinuxAppDev  o2	 Public    Videos

localhost% ls > o
localhost% cat o
bin
d
d1
d34
Desktop
Documents
dotfiles
Downloads
dwe
file
LinuxAppDev
Methodics_of_LinuxAppDev
Music
o
o1
o2
o3
oqwer
Pictures
Public
Py.py
pythonprac
Templates
Videos

localhost% wc
qwert
asdfghj
zxcvbnm,lkjhgfdsa
      3       3      32
localhost% wc < o
 24  24 169
```
 + `|` - конвейер, вывод левого операнда передаётся на вход правому операнду
```console
stephen@localhost:~> ls -l /usr/bin | grep ls | wc
     49     453    2964
stephen@localhost:~> 

```

```console
localhost% { ls o?; ls d?;}
o1  o2	o3
d1

localhost% { ls o*; ls d*;}
o  o1  o2  o3  oqwer
d  d1  d34  dwe

dotfiles:
alacritty  bash  init_bash_vim_conf.bash  lf  neofetch	nixos  nvim  vim

localhost% { ls o?; ls q?;} > o 2>&1
localhost% cat o
o1
o2
o3
zsh: no matches found: q?
```
 + `<<` - Ввод до определённых данных с входного потока
```console
stephen@localhost:~> cat > file <<EOF
> Hello
> Im
> Here
> 
> EOF
stephen@localhost:~> cat file
Hello
Im
Here

stephen@localhost:~> 
```

#### Условный оператор (if-fi)
Вид выражения `if` **expr**; `then` **scrypt**; `else` **scrypt**; `fi`

В качестве выражения условия у нас используется результат работы операций над данными или результат зевершения (корректного или нет) запускаемой программы.
```console
stephen@localhost:~> if ls o?; then echo QQ; fi
o1  o2  o3
QQ

stephen@localhost:~> if ls q?; then echo QQ; fi
ls: cannot access 'q?': No such file or directory

stephen@localhost:~> if ls q?; then echo QQ; else echo "==$?"; fi
ls: cannot access 'q?': No such file or directory
==2

```

#### Цикл
1. Цикл с условием: Вид выражения `while` **expr**; `do` **scrypt**; `done`
2. Цикл по последовательности: `for` **var** `in` **seq_expr**; `do` **scrypt**; `done`

```console
localhost% while [ $a -lt 6 ]; do
echo "Hello $a"; read a; done
Hello 1
3
Hello 3
2
Hello 2
5
Hello 5
8
localhost% 
```

```console
localhost% for i in o? d?; do echo "Find ${i}"; done  
Find o1
Find o2
Find o3
Find d1
localhost% 
```

Более сложный пример, основанный на использовании программ в условиях: автоматически меняющийся `ls`:
```console
stephen@localhost:~> a="."
stephen@localhost:~> while ls $a; do
> read a
> echo "$a"
> done
bin  Desktop    dwe                       Music  o3        Py.py
d    Documents  file                      o      oqwer     pythonprac
d1   dotfiles   LinuxAppDev               o1     Pictures  Templates
d34  Downloads  Methodics_of_LinuxAppDev  o2     Public    Videos

o*
o*
o  o1  o2  o3  oqwer
o1
o1
o1
P*
P*
Py.py

Pictures:
Me.jpg              Screenshot_2024-08-10_16-34-03.png  vscode.svg
MK_2redaction.jpeg  Screenshot_2024-08-10_16-34-25.png  Witcher.jpg
PC_cat.jpg          Tmp_Videos                          Zastavka.gif

Public:

bin  Desktop    dwe                       Music  o3        Py.py
d    Documents  file                      o      oqwer     pythonprac
d1   dotfiles   LinuxAppDev               o1     Pictures  Templates
d34  Downloads  Methodics_of_LinuxAppDev  o2     Public    Videos
^C
stephen@localhost:~> 
```

Для проверки условия в примерах выше мы использовали утилиту `test`, а, точнее, её шорт-кат \[ (он принимает 4 аргумента: левый операнд, операцию, правый операнд и закрывающую скобку ] )
```console
stephen@localhost:~> if test 1 = 2; then echo qq; else echo qwer; fi
qwer
stephen@localhost:~> if test 2 = 2; then echo qq; else echo qwer; fi
qq
stephen@localhost:~> if [ 2 = 2 ]; then echo qq; else echo qwer; fi
qq
```

Также нами использовалась утилита `read`, работающая построчным считывателем данныхи разбиением их разделителями на элементы для связывания с переменными. При этом последнее связывание происходит на весь оставшийся незаписанный поток информации

```console
stephen@localhost:~> cal | while read a b c; do
> echo $c $b $a; done
2024 October
Tu We Th Fr Sa Mo Su
3 4 5 2 1
8 9 10 11 12 7 6
15 16 17 18 19 14 13
22 23 24 25 26 21 20
29 30 31 28 27

stephen@localhost:~> cal
    October 2024    
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31      
                    
stephen@localhost:~> cal | while read a b c; do echo $c //  $b // $a; done
// 2024 // October
Tu We Th Fr Sa // Mo // Su
3 4 5 // 2 // 1
8 9 10 11 12 // 7 // 6
15 16 17 18 19 // 14 // 13
22 23 24 25 26 // 21 // 20
29 30 31 // 28 // 27
// //
stephen@localhost:~> 

```

---
В Шелле есть `case` и шаблоны

---
---
---
В действительности, на Шелле свет клином не сошёлся
 + find находит файлы по предикатам в указанном дереве ФС
```console
stephen@localhost:~> find /usr/bin -perm -2000
/usr/bin/chage
stephen@localhost:~> 

stephen@localhost:~> find /usr/bin -perm -2000 -exec ls -l {} \;
-rwxr-sr-x 1 root shadow 84944 Jul  8 14:13 /usr/bin/chage
stephen@localhost:~> 
```
 + xargs - подаёт программе поток данных, как аргументы
```console
stephen@localhost:~> ls | xargs echo "QQ"
QQ bin d d1 d34 Desktop Documents dotfiles Downloads dwe file LinuxAppDev Methodics_of_LinuxAppDev Music o o1 o2 o3 oqwer Pictures Public Py.py pythonprac Templates Videos
stephen@localhost:~> ls | xargs -n1 echo "QQ"
QQ bin
QQ d
QQ d1
QQ d34
QQ Desktop
QQ Documents
QQ dotfiles
QQ Downloads
QQ dwe
QQ file
QQ LinuxAppDev
QQ Methodics_of_LinuxAppDev
QQ Music
QQ o
QQ o1
QQ o2
QQ o3
QQ oqwer
QQ Pictures
QQ Public
QQ Py.py
QQ pythonprac
QQ Templates
QQ Videos
stephen@localhost:~> 
```

 + mktemp - АТОМАРНО заводит временный файл со случайным именем и возвращает его имя(гарантируется уникальность имени)
```console
stephen@localhost:~> mktemp
/tmp/tmp.4qOGaAWzUL

```

---

Программа:
```
#!/bin/sh
exit_handler() {
  trap - EXIT
  test -r "$TMPFILE" && rm -vf "$TMPFILE"
}
trap exit_handler EXIT HUP INT QUIT PIPE TERM
echo -n "Create a file? "
read YN
if [ "$YN" = y ]; then
        TMPFILE="$(mktemp)"
        echo "$TMPFILE"
        ls -l "$TMPFILE"
fi
echo -n "Wait…"
read
echo "Done"
```

1
```
stephen@localhost:~/LinuxAppDev/03_Text/Lection> sh mktemp_prog
Create a file? y
/tmp/tmp.0HpoFrspx2
-rw------- 1 stephen stephen 0 Oct  1 17:26 /tmp/tmp.0HpoFrspx2
Wait…
```
2
```
stephen@localhost:~> cd /tmp
stephen@localhost:/tmp> ls
f79d601e26a782fd149b3ffb098aae9f-{87A94AB0-E370-4cde-98D3-ACC110C5967D}
scoped_dir385nwx
ssh-XXXXXXOew8ft
systemd-private-392d4b2dc08641538096d0963581beb3-bluetooth.service-pCCKOD
systemd-private-392d4b2dc08641538096d0963581beb3-chronyd.service-vMwgUP
systemd-private-392d4b2dc08641538096d0963581beb3-colord.service-xh3Wng
systemd-private-392d4b2dc08641538096d0963581beb3-dbus-broker.service-Xc9JMH
systemd-private-392d4b2dc08641538096d0963581beb3-irqbalance.service-2tOaUx
systemd-private-392d4b2dc08641538096d0963581beb3-ModemManager.service-ADbhrR
systemd-private-392d4b2dc08641538096d0963581beb3-polkit.service-Ejs5mb
systemd-private-392d4b2dc08641538096d0963581beb3-systemd-logind.service-EIewLu
systemd-private-392d4b2dc08641538096d0963581beb3-upower.service-jjkKzI
tmp.0HpoFrspx2

```

1
```

Done
removed '/tmp/tmp.0HpoFrspx2'
stephen@localhost:~/LinuxAppDev/03_Text/Lection> 

```
2
```console
stephen@localhost:/tmp> ls
f79d601e26a782fd149b3ffb098aae9f-{87A94AB0-E370-4cde-98D3-ACC110C5967D}
scoped_dir385nwx
ssh-XXXXXXOew8ft
systemd-private-392d4b2dc08641538096d0963581beb3-bluetooth.service-pCCKOD
systemd-private-392d4b2dc08641538096d0963581beb3-chronyd.service-vMwgUP
systemd-private-392d4b2dc08641538096d0963581beb3-colord.service-xh3Wng
systemd-private-392d4b2dc08641538096d0963581beb3-dbus-broker.service-Xc9JMH
systemd-private-392d4b2dc08641538096d0963581beb3-irqbalance.service-2tOaUx
systemd-private-392d4b2dc08641538096d0963581beb3-ModemManager.service-ADbhrR
systemd-private-392d4b2dc08641538096d0963581beb3-polkit.service-Ejs5mb
systemd-private-392d4b2dc08641538096d0963581beb3-systemd-logind.service-EIewLu
systemd-private-392d4b2dc08641538096d0963581beb3-upower.service-jjkKzI
stephen@localhost:/tmp> 

```

----
----
----
GNU coreutils - утилиты работы с текстом. Выковырять что-то из текстового потока, изменить, применить итд

```console
ps -eo pid,time | sort | tee text1
ps -eo pid,comm | sort | tee text2
join text1 text2
```



---
```console
stephen@localhost:~/LinuxAppDev/03_Text/Lection> date 
Tue Oct  1 17:39:00 MSK 2024
stephen@localhost:~/LinuxAppDev/03_Text/Lection> date | hehdump -C
 hehdump: command not found
stephen@localhost:~/LinuxAppDev/03_Text/Lection> date | hexdump -C
00000000  54 75 65 20 4f 63 74 20  20 31 20 31 37 3a 33 39  |Tue Oct  1 17:39|
00000010  3a 31 34 20 4d 53 4b 20  32 30 32 34 0a           |:14 MSK 2024.|
0000001d
stephen@localhost:~/LinuxAppDev/03_Text/Lection> date | xxd       
00000000: 5475 6520 4f63 7420 2031 2031 373a 3339  Tue Oct  1 17:39
00000010: 3a32 3120 4d53 4b20 3230 3234 0a         :21 MSK 2024.
stephen@localhost:~/LinuxAppDev/03_Text/Lection> rpm -qf =hexdump
error: file /home/stephen/LinuxAppDev/03_Text/Lection/=hexdump: No such file or directory
stephen@localhost:~/LinuxAppDev/03_Text/Lection> rpm -qf hexdump
error: file /home/stephen/LinuxAppDev/03_Text/Lection/hexdump: No such file or directory
stephen@localhost:~/LinuxAppDev/03_Text/Lection> rpm -qf /usr/bin/hexdump
util-linux-2.40.1-5.1.x86_64
stephen@localhost:~/LinuxAppDev/03_Text/Lection> 

stephen@localhost:~/LinuxAppDev/03_Text/Lection> date | od 
0000000 072524 020145 061517 020164 030440 030440 035067 030064
0000020 032072 020067 051515 020113 030062 032062 000012
0000035
stephen@localhost:~/LinuxAppDev/03_Text/Lection> rpm -qf /usr/bin/od     
coreutils-9.5-3.1.x86_64
stephen@localhost:~/LinuxAppDev/03_Text/Lection> 

stephen@localhost:~/LinuxAppDev/03_Text/Lection> rpm -qf /usr/bin/xxd
xxd-9.1.0718-1.1.x86_64
stephen@localhost:~/LinuxAppDev/03_Text/Lection> rpm -qf /usr/bin/vim
vim-9.1.0718-1.1.x86_64
gvim-9.1.0718-1.1.x86_64
stephen@localhost:~/LinuxAppDev/03_Text/Lection> 

```

---
---
---
Комбайны

 + grep - `g/re/p` из `ed`
```console
stephen@localhost:~> cat Py.py 
a = []
while s:= input():
    a.append(eval(s))

for i in range(len(a[0])):
    for j in range(i+1, len(a[0])):
        a[i][j], a[j][i] = a[j][i], a[i][j]

print(*a, sep = '\n')
stephen@localhost:~> grep ra* Py.py 
for i in range(len(a[0])):
    for j in range(i+1, len(a[0])):
print(*a, sep = '\n')
stephen@localhost:~> 

```
 + sed

```console
stephen@localhost:~> cal | sed 's/\([01]\)\([2-3]\)/\2:\1/g'
    October 22:04    
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 2:1
3:1 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31      
                    
stephen@localhost:~> 

```

